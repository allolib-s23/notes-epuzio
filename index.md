### Notes from Esmé Puzio

# Compositions
## Piece 1: Boy’s a Liar
[Link to composition](https://github.com/allolib-s23/demo1-epuzio/blob/master/tutorials/synthesis/00_SineEnv_Pink.cpp)

To play: run ./run.sh tutorials/synthesis/00_SineEnv_Pink.cpp .

This is a transcription of Boy’s a Liar by Pink Panthress written within Allolib. I chose to transcribe this piece because of the variety of instruments in the song, and the way that each layer of instrumentation builds upon the previous one. Through this piece, I learned the basics of composing pop music within Allolib, and how to compose simple melodies using different instruments. I also learned how to create functions to time notes properly when playing through Allolib.

## Piece 2: DogLove (Original Composition)
[Link to composition](https://github.com/allolib-s23/demo1-epuzio/blob/master/tutorials/synthesis/00_DogLoveGenerativeDemo.cpp)

To play: run ./run.sh tutorials/synthesis/00_DogLoveGenerativeDemo.cpp .

With this piece, I wanted to incorporate randomness into an original composition based around the work of Devi McCallion/Girls Rituals. The piece incorporates randomness in the number of phrases at the start (1, 2 or 3), the number of phrases at the bridge (1 or 2), the patterns of the hi-hat and bass (choosing from 4 preset options), the notes played in the arpeggios (which were based on randomly chosen chord inversions) and the scale the piece was played in. I used this piece to demo the note transposition function and chord builder function I created in randomnessHelper.h, since the note transposition function made it easy to change between major scales. This piece is loosely inspired by the work of Devi McCallion/Girls Rituals/Mom, especially the songs “Bloodeater”, “I [Mess] Everything Up” and “Un See Through”.

## Piece 3: DogLove V2 (Original Composition)
[Link to composition](https://github.com/allolib-s23/demo1-epuzio/blob/master/tutorials/synthesis/00_DogLoveV2.cpp)

To play: run ./run.sh tutorials/synthesis/00_DogLoveV2.cpp and press any key.

This piece was a reworked version of my original piece that used the axis chord progression function in randomnessHelper.H to create random chord progressions and varied arpeggios every time the piece was played. I also added graphics for the main chord progression and accompanying chord progression based on Grace and Aviv’s demos.

## Piece 4: Poe’s Walk (Original Composition/Collaboration)
[Link to composition](https://github.com/allolib-s23/demo1-epuzio/blob/master/tutorials/synthesis/00_PoesWalk.cpp)

To play: run ./run.sh tutorials/synthesis/00_PoesWalk.cpp and press any key.

This piece is a demonstration of two features in randomnessHelper.H - the Linear Feedback Shift Register and Markov melody generator. Starting in C major, the melody runs a stochastic walk that’s completely generated by a 1-D Markov chain. The probability for the next note is calculated based on potential chords that can be formed using the current note as the root. The same stochastic walk is used to create backing chords using sine and sawtooth waves. In addition, the snare sound is pseudorandomly generated using a LFSR sequence with 5 registers, repeating every 31 beats.
This piece is loosely inspired by the song “You Can’t Stop Me” by Alex G from the film “We’re All Going To The World’s Fair”.

## Piece 5: Worst In Me 
[Link to composition](https://github.com/allolib-s23/demo1-epuzio/blob/master/tutorials/synthesis/00_WorstInMe.cpp)

To play: run ./run.sh tutorials/synthesis/00_WorstInMe.cpp and press any key.

This piece is a transcription of the song “Worst In Me” by Devi McCallion/Girls Rituals written within Allolib. I chose to arrange this piece in particular because Devi McCallion’s beats follow simple chord structures and often incorporate randomness. I used al_SoundFile to play vocals alongside the piece, which I created using the Eleanor Forte Lite voicebank for Synthesizer V Studio Basic. My goal for this piece was to create a song that incorporated both instruments and vocals. Unfortunately, for whatever reason, allolib speeds up the .wav file I included as vocals for this piece, so the instrumentation and vocals are not perfectly synched, and it does not sound very good.

# Helper class:
## randomness.h
[Link to helper](https://github.com/allolib-s23/demo1-epuzio/blob/master/tutorials/synthesis/randomness.h)
This helper class includes a few functions which can help provide elements of randomness in a piece of music.
  * getFreq(int n, int octave, int transpose = 0)
  * * Given the name of a note, octave and number of half-steps to transpose the note, returns a frequency corresponding to that note. This function makes it easy to transpose pieces of music by passing in a single value, and makes it so that the user doesn't need to hardcode frequencies in their demos.
    * * The program [00_transpose_demo](https://github.com/allolib-s23/demo1-epuzio/blob/master/tutorials/synthesis/00_transpose_demo.cpp) is what I initially showed in class to demonstrate transposition.
  * axisProgression(string n, int octave, int transpose = 0)
   * * Given a starting note, selects from 4 preset orders of chords with random inversions corresponding to the axis progression, transposed into the scale of the starting note. The axis progression is the four chords most commonly associated with pop music (C, Am, F, G).
  * getMarkovNotes(string n, int octave, int transpose, int sequenceLength)
   * * Given a starting note, computes a random sequence of notes using Markov chains. The next note in the sequence is calculated based on a transition matrix for the current note.
  * getNoteSpacingForMeasure(int numNotes)
   * * Given a certain number of notes, this function calculates the probability of a certain note falling on a certain beat based on the number of notes and number of beats remaining in the measure, and returns a boolean vector corresponding to whether or not a note should be played on a certain beat.
  * getFibLFSRSequence(int seed, int numBits, int sequenceLength)
   * * This function simulates a Fibonacci Linear Feedback Shift Register. This is a little more  complex than the other functions in this helper, but briefly speaking, the LFSR is a set of registers which store previous output bits, and calculate the next output bit using the values stored at certain registers in this set. If the registers used to calculate the next output bit are chosen correctly, the shift registers will cycle through all possible states, creating a pseudorandom sequence that’s 2^m -1, where m is the number of registers storing previous output bits. For more information, please visit https://simple.wikipedia.org/wiki/Linear-feedback_shift_register, which provides a helpful gif illustrating the process for a 4-bit LFSR.
   * * The seed field is the pseudorandom seed used to generate the sequence, numBits are the number of bits corresponding to previous stages that we store in the LFSR, and sequenceLength is how long we want the output to be.
   * * Linear Feedback Shift Registers can be used to output pseudorandom drum beats that loop after a certain number of measures. Given the same seed, the LFSR will always generate the same pattern of output bits, so users can experiment with providing different seeds to the LFSR to find drum patterns that suit their compositions.
